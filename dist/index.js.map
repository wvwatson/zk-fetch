{"version":3,"sources":["../src/index.ts","../src/zkfetch.ts","../src/types.ts","../src/errors.ts","../src/utils.ts","../src/constants.ts"],"sourcesContent":["export * from './zkfetch'\nexport * from './types'","import { createClaimOnWitness } from \"@reclaimprotocol/witness-sdk\";\nimport { HttpMethod, LogType } from \"./types\";\nimport { Options, secretOptions } from \"./interfaces\";\nimport {\n  assertCorrectnessOfOptions,\n  validateURL,\n  sendLogs,\n  validateApplicationIdAndSecret,\n  assertCorrectionOfSecretOptions,\n} from \"./utils\";\nimport { v4 } from \"uuid\";\nimport P from \"pino\";\nimport { FetchError } from \"./errors\";\nimport { WITNESS_NODE_URL } from \"./constants\";\nconst logger = P();\n\nexport class ReclaimClient {\n  applicationId: string;\n  applicationSecret: string;\n  logs?: boolean;\n  sessionId: string;\n  constructor(\n    applicationId: string,\n    applicationSecret: string,\n    logs?: boolean\n  ) {\n    validateApplicationIdAndSecret(applicationId, applicationSecret);\n    this.applicationId = applicationId;\n    this.applicationSecret = applicationSecret;\n    this.sessionId = v4().toString();\n    // if the logs are enabled, set the logger level to info\n    logger.level = logs ? \"info\" : \"silent\";\n    logger.info(\n      `Initializing client with applicationId: ${this.applicationId} and sessionId: ${this.sessionId}`\n    );\n  }\n\n  async zkFetch(\n    url: string,\n    options?: Options,\n    secretOptions?: secretOptions,\n    retries = 1,\n    retryInterval = 1000\n  ) {\n    validateURL(url, \"zkFetch\");\n    if (options !== undefined) {\n      assertCorrectnessOfOptions(options);\n    }\n    if (secretOptions)  {\n      assertCorrectionOfSecretOptions(secretOptions);\n    }\n    const fetchOptions = {\n                method: options?.method || HttpMethod.GET,\n                body: options?.body,\n                headers: { ...options?.headers, ...secretOptions?.headers },\n    };\n    await sendLogs({\n      sessionId: this.sessionId,\n      logType: LogType.VERIFICATION_STARTED,\n      applicationId: this.applicationId,\n    });\n\n    let attempt = 0;\n    while (attempt < retries) {\n      try {\n        const response = await fetch(url, fetchOptions);\n        if (!response.ok) {\n          throw new FetchError(\n            `Failed to fetch ${url} with status ${response.status}`\n          );\n        }\n        const fetchResponse = await response.text();\n        const claim = await createClaimOnWitness({\n          name: 'http',\n          params: {\n            method: fetchOptions.method as HttpMethod,\n            url: url,\n            responseMatches: [\n              {\n                type: \"contains\",\n                value: fetchResponse,\n              },\n            ],\n            headers: options?.headers,\n            geoLocation: options?.geoLocation,\n            responseRedactions: [],\n            body: fetchOptions.body,\n          },\n          secretParams: {\n            cookieStr: \"abc=pqr\",\n            ...secretOptions,\n          },\n          ownerPrivateKey: this.applicationSecret,\n          logger: logger,       \n          client: {\n            url: WITNESS_NODE_URL,\n          }\n        });\n\n        await sendLogs({\n          sessionId: this.sessionId,\n          logType: LogType.PROOF_GENERATED,\n          applicationId: this.applicationId,\n        });\n        return claim;\n      } catch (error: any) {\n        attempt++;\n        if (attempt >= retries) {\n          await sendLogs({\n            sessionId: this.sessionId,\n            logType: LogType.ERROR,\n            applicationId: this.applicationId,\n          });\n          logger.error(error);\n          throw error;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryInterval));\n      }\n    }\n  }\n\n}\n","export enum HttpMethod {\n    GET = \"GET\",\n    POST = \"POST\",\n}\n\nexport enum LogType {\n    VERIFICATION_STARTED = 'VERIFICATION_STARTED',\n    PROOF_GENERATED = 'PROOF_GENERATED',\n    ERROR = 'ERROR',\n    SUCCESS = 'SUCCESS',\n    FAILED = 'FAILED'\n}\n\nexport type ProofRequestOptions = {\n    log?: boolean;\n    sessionId?: string;\n}  \n\nexport type ApplicationId = string;\nexport type ApplicationSecret = string;\nexport type RequestUrl = string;\nexport type ProviderId = string;\nexport type NoReturn = void;\nexport type SessionId = string;","export class InvalidParamError extends Error {\n    constructor(message?: string) {\n        super(message)\n        this.name = 'InvalidParamError'\n    }\n}\n\n\nexport class DisallowedOptionError extends Error {\n    constructor(message?: string) {\n        super(message)\n        this.name = 'DisallowedOptionError'\n    }\n}\n\nexport class InvalidMethodError extends Error {\n    constructor(message?: string) {\n        super(message)\n        this.name = 'InvalidMethodError'\n    }\n}\n\nexport class FetchError extends Error {\n    constructor(message?: string) {\n        super(message)\n        this.name = 'FetchError'\n    }\n}\n\nexport class NetworkError extends Error {\n    constructor(message?: string) {\n        super(message)\n        this.name = 'NetworkError'\n    }\n}\n\nexport class ApplicationError extends Error {\n    constructor(message?: string) {\n        super(message)\n        this.name = 'ApplicationError'\n    }\n}","import { ApplicationError, DisallowedOptionError, InvalidMethodError, InvalidParamError, NetworkError } from './errors';\nimport { ApplicationId, ApplicationSecret, HttpMethod } from './types'\nimport { Options, secretOptions, SendLogsParams } from './interfaces';\nimport { ethers } from 'ethers';\nimport { APP_BACKEND_URL, LOGS_BACKEND_URL } from './constants';\nimport P from \"pino\";\nconst logger = P();\n\n/*\n  Options validations utils\n*/\nexport function assertCorrectnessOfOptions(options: Options): void {\n  if (!options.method) {\n    throw new InvalidParamError('Method is required');\n  }\n  if (options.method !== HttpMethod.GET && options.method !== HttpMethod.POST) {\n     throw new InvalidMethodError(`Method ${options.method} is not allowed`);\n  }\n}\n\nexport function assertCorrectionOfSecretOptions(secretOptions: secretOptions): void {\n  if(secretOptions.body){\n    throw new DisallowedOptionError(`Option: body is not allowed`);\n  }\n}\n\n\n/*\n  Params validations utils\n*/\nexport function validateNotNullOrUndefined(input: any, paramName: string, functionName: string) {\n    if (input == null) {\n      throw new InvalidParamError(`${paramName} passed to ${functionName} must not be null or undefined.`);\n    }\n  }\n  \n  export function validateNonEmptyString(input: string, paramName: string, functionName: string) {\n    if (typeof input !== 'string') {\n      throw new InvalidParamError(`${paramName} passed to ${functionName} must be a string.`);\n    }\n    if (input.trim() === \"\") {\n      throw new InvalidParamError(`${paramName} passed to ${functionName} must be a non-empty string.`);\n    }\n  }\n\n\n/* validate applicationId and applicationSecret */\nexport function validateApplicationIdAndSecret(applicationId: ApplicationId, applicationSecret: ApplicationSecret): void {\n  validateNotNullOrUndefined(applicationId, 'applicationId', 'the constructor');\n  validateNonEmptyString(applicationId, 'applicationId', 'the constructor');\n  validateNotNullOrUndefined(applicationSecret, 'applicationSecret', 'the constructor');\n  validateNonEmptyString(applicationSecret, 'applicationSecret', 'the constructor');\n try{\n    const wallet = new ethers.Wallet(applicationSecret);\n    if(wallet.address !== applicationId){\n      throw new InvalidParamError(`Invalid applicationId and applicationSecret passed to the constructor.`);\n    }\n }\n  catch (error) {\n    throw new InvalidParamError(`Invalid applicationId and applicationSecret passed to the constructor.`);\n  }\n}\n\n/* \n  URL validations utils\n*/\nexport function validateURL(url: string, functionName: string): void {\n    validateNotNullOrUndefined(url, 'url', functionName)\n    validateNonEmptyString(url, 'url', functionName)\n    try {\n      new URL(url);\n    } catch (e) {\n      throw new InvalidParamError(`Invalid URL format passed to ${functionName}.`);\n    }\n  }\n   \n\n// cache for app name to avoid multiple fetches \nconst appNameCache: { [key: string]: string } = {};\nexport async function fetchAppById(appId: string): Promise<string> {\n  if (appNameCache[appId]) {\n    return appNameCache[appId];\n  }\n  try {\n    const response = await fetch(`${APP_BACKEND_URL}/api/zkfetch/sdk/${appId}`);\n    if (response.status === 404) {\n      throw new ApplicationError('Application not found');\n    }\n    if (response.status !== 200) {\n      throw new ApplicationError('Failed to fetch application');\n    }\n\n    const res = await response.json();\n    const appName = res.application.applicationName;\n    appNameCache[appId] = appName; // Update cache\n    return appName;\n  } catch (err) {\n    throw new ApplicationError('Application not found');\n  }\n}\n\n/* \n sendLogs utils\n*/\nexport async function sendLogs(\n  { \n      sessionId, \n      logType, \n      applicationId,\n      }: SendLogsParams\n  ): Promise<void> {\n    try {\n      const getAppName = await fetchAppById(applicationId);\n      const url = `${LOGS_BACKEND_URL}/api/business-logs/zkfetch`\n      const body = JSON.stringify({\n          sessionId,\n          logType,\n          date: new Date().toISOString(),\n          applicationId: applicationId,\n          applicationName: getAppName,\n      })\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body,\n      })\n  \n      if (!response.ok) {\n        logger.error('Failed to send logs')\n      }\n    } catch (error) {\n      if (error instanceof ApplicationError) {\n        throw error\n      } \n      throw new NetworkError('Failed to send logs')\n    }\n  }\n  ","const LOGS_BACKEND_URL = \"https://logs.reclaimprotocol.org\"\nconst APP_BACKEND_URL = \"https://api.reclaimprotocol.org\"\nconst WITNESS_NODE_URL = \"wss://witness.reclaimprotocol.org/ws\"\n\n\nexport { LOGS_BACKEND_URL, APP_BACKEND_URL, WITNESS_NODE_URL }"],"mappings":"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","names":["HttpMethod","LogType","P","import_pino","logger","P"]}